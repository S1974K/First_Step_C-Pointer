章構成proto ver.2

# 第一章

## この章でわかること
- ポインタとは何か
- ポインタとメモリの関係性について
- ポインタのはたらき

## 1.1 ポインタを学ぶ前の確認事項
この教材は、C言語のポインタおよびそれに関連の深い事項に焦点を強く当てて学ぶものである。そのため、プログラミングの初歩的な知識やC言語の基本的な文法については予め理解していることを前提に進んでいく。学習者は以下の知識について習得していない場合、初歩的な内容を別媒体で学んでおくことを強く推奨する。
・C言語のコードの基本的な書き方と標準出力方法
・変数の型と宣言
・配列の型と宣言
・Cの演算子の優先順位

## 1.2 アドレスとメモリ

！重要！
- アドレスとは、データを保管するメモリ部分における区画ごとに割り振られ、その区画を示す数字である。
- アドレスは1バイトごとに一つ割り当てられており、データはその型に応じて占領する区画の大きさが異なる。
- データを参照したい場合、そのデータの型とデータの格納されているアドレスがわかっていれば、データを呼び出すことができる。

C言語におけるポインタの概念を理解する前に、アドレスをは何かを理解する必要がある。ここでは、アドレスは何であるかを正しく理解することを目的とする。
アドレスとは、コンピュータが読み書きに使用するデータを保管している「メモリ」に関する概念だ。コンピュータでデータを扱う際、それらを格納し保存する記憶領域である「メモリ」に、区画ごとの整理のための番地のような番号が振られている。この区画ごとの番号を「アドレス」と呼び、格納されている情報にアクセスするのに使われる。格納されている値に必要なバイト数に応じて、割り当てられるアドレスの範囲が変化する。
具体例として、仮に0000から0099まで、通し番号のように用意されたメモリが存在すると仮定する。

アドレスというのは、ある値がメモリのどの場所に保存されているかを指す値だ。この時、int aとint bという変数がそれぞれ定義され値を持っているとすると、int aの値が格納されているメモリのアドレスとint bの値が格納されているメモリのアドレスがそれぞれ存在するということになる。
この節では仮に、aがアドレス0000-0003の範囲に、bがアドレス0004-0007の範囲に収納されていることにする。

「アドレスが番地なのであれば単純に一つずつ値を対応させて、aが0000、bが0001に格納されるのではダメなのか？」と考えることもできる。こうならない理由を理解することは、アドレスに関する事象を扱うのに大切である。
アドレスとメモリを理解するのに重要な要素に、データの型におけるサイズがある。このサイズは、その型がどのような大きさのバイト長を持つのかを表すものだ。ここでは、型のサイズがそれぞれ以下の大きさであるとする。
	int 4バイト
	char 1バイト
メモリに保存されるデータはそれぞれ型のサイズに合うバイト数を占拠する。アドレスは1つの値で1バイト分の数値を表すため、1バイトより大きいサイズを持つデータはその分だけ連続したアドレスの領域を使用することになる。従って、仮に数字の若いアドレスに優先して格納していくとする時、intの値aをアドレス0000に収納すると、intのバイト長である4バイト分のアドレスを消費し、次に収納するintの値bはアドレス0000より4バイト分先にある0004か、それよりも遠い所にあるアドレスの場所に、同じく4バイト分のアドレスを消費するように収納されるということになる。

基本的にプログラムでは、このメモリ部分に変数の情報などを格納し、メモリから必要な情報を参照して使用する。参照の際、以下の2つの要素がわかっていれば、メモリからデータを呼び出すことができる。
	- 取り出したいデータの型
	- 取り出したいデータの格納されているアドレス
取り出したいデータの型が判明していれば、そのデータが何バイトぶんのメモリを使用しているかがわかる。取り出したいデータの格納されているアドレスが判明していれば、そのデータがメモリのどの部分に格納されているかがわかる。この二つの情報を使って、プログラムでは格納されたデータを引き出すことができるということである。

## 1.3 C言語におけるポインタ

！重要！
- ポインタ型とは、他の型から派生するように作られる型であり、ポインタ型を持つデータはアドレスを指している。
- ポインタ型の変数を宣言する際は、”int *a_pointer”, “char *s_pointer”などのように、”(アドレスの先に格納されるデータの型) *()”の形で宣言する。
- ポインタ型の変数

### 1.3-1　ポインタとは何か
先の節で解説したアドレスとメモリの概念は、「ポインタ」の概念を理解するのに必要な知識である。

ポインタとは、何らかの型を持つ値の格納されているアドレスを指し示すものである。アドレスを指し示す値であれば「ポインタ値」、アドレスを指し示す型を指すのであれば「ポインタ型」、アドレスを指し示す値が入る変数であれば「ポインタ変数」となり、どの場合でも意味を広くとって「ポインタ」とだけ示されることも多い。混乱を防ぎたい場合は、「ポインタ値」「ポインタ型」「ポインタ変数」を書き分けるのが良い。すでに存在する型Xに対し、あるX型のデータのアドレスを指し示す型を、X型のデータへのアドレスを持つ型という意味で「Xへのポインタ型」と呼ぶ。

例として、1.2節で登場した変数a, bを挙げて考える。
int型の変数であるaを指し示すアドレス0000を格納する変数a_pointerは「intへのポインタ型」をとる。同様に、int型の変数であるbを指し示すアドレス0004を格納する変数b_pointerも「intへのポインタ型」をとる。

ポインタ型がポインタ先のデータの型を情報に持つのは、その情報がないとそのポインタ型のデータが指し示すものをメモリから正確に取得できないからである。
1.2で述べたように、メモリからデータを取り出すには、以下の二つの情報が必要である。
	- 取り出したいデータの型
	- 取り出したいデータの格納されているアドレス
ポインタ型の変数は、ポインタを辿った先にあるデータの型名を情報として保有する。この情報と変数内の値（アドレス）を使用することで、メモリから必要なデータを取り出すことができるようになっているということである。

### 1.3-2　ポインタの宣言
基本的な型を指すポインタ変数は、ポインタが指す型と宣言する変数名によって
	(ポインタが指す型) *(変数名)
と宣言する。具体的な宣言例は以下の通りである。

	int *a; //int型の値へのポインタa
	char *b; //char型の値へのポインタb

アドレスを持つ値の型は、それが指す値の型によって変化する。上記の例で宣言したポインタ変数は、それぞれ「intへのポインタ型」「charへのポインタ型」である。
変数の宣言は型名と変数名の組み合わせで行われるが、ポインタであることを表す*は型名の一部であることに注意が必要である。このため、コードで宣言した上記のポインタ変数を
使用する際は、変数名に*を添えない。
ポインタ変数は他の変数と同様に扱われる。例えば、ポインタ変数aに何かのポインタの値を代入したい時は、a = ...と記述する。次節以降で説明するが、*a = ...としてしまうと*が別の意味を持ち意図している挙動とは異なるコードとなるので混同しないよう注意すること。
間違っている例として、以下のような状況を挙げておく。
先ほど宣言したポインタaの他に、同じくint型の値を指すアドレスxがあるとする。aもxもint型への

また、指し示す先が型であればポインタ型は新しく作成できる。したがって、intやcharなど基本的な型でなくともポインタ型を作ることができる。

配列に関する型の具体例は以下の通りである。
	int (*p_array)[10]; //int型の要素を持つ要素数10の配列へのポインタp_array
	int *p_array_two[10]; //intへのポインタを要素に持つ要素数10の配列

上二つの変数宣言は先のもの一見同じに見えるが、実際は異なるものである。
二つの変数宣言の違いは次のように表すことができる。
int (*p_array)[10]の変数名はp_arrayであり、()で囲われたものは優先的に処理されるので、p_arrayはポインタ型であるということがわかる。*p_arrayをPと書き換えると、
int P[10]となり、Pはint型の要素を持つ要素数10の配列であることがわかる。したがって、p_arrayはポインタであり、int型の要素を持つ要素数10の配列を指していることがわかる。

一方で、int *p_array_two[10]という宣言の場合、p_array_twoの左にある*はp_array_twoではなくintとセットになっているものである。これは、*がポインタ型を示すものであり、
int *aと宣言されたaの型はint*型（intへのポインタ型）であることを考えると理解しやすい。したがって、p_array_twoは後ろにある配列型を示す[10]とセットである。
よって、int *p_array_two[10]はint*型によって構成されている要素数10の配列型であるということがわかる。

ポインタ型もまた型の一つであるため、ポインタ型のポインタを作成することも可能である。
	int **p_pointer; //「int型へのポインタ」を指すポインタ変数p_pointer

さらに、関数を指すポインタも指定することができる。関数へのポインタを利用することで、ポインタを通して間接的に関数を呼び出すことができるようになる。
	int (*p_func)(int, *char); //int型の戻り値を持ち、引数にint型とcharへのポインタ型を持つ関数へのポインタp_func

### 1.3-3　ポインタの読み方/書き方がわからない時は？
前の節で述べたポインタ変数およびポインタに関連するの宣言は、如何様にも複雑化する可能性がある。ポインタを正しく利用し理解するために、ポインタ変数の読み方と書き方について勉強しておくのが良い。

ポインタは派生型であるというのは他の節の中で語ったことである。ポインタ型はアドレスが指す値の型の派生型として作られるものであり、型名に派生元の型を含む。また、ポインタ型自身も型であり、ポインタ型から別の型へ派生させることも可能である。従って、ポインタに関する型は複雑化させることもでき、複雑化すればするほど読解が難解になる。

基本的に、ポインタを正確に読むには以下の手順が必要である。
1. 識別子に注目する。識別子とは変数名や関数名など、特定のデータに識別のため付けられる固有名詞のようなものである。すべての表現がこの識別子を修飾するように説明しており、原点となる識別子を定めないことには何も始まらないからである。
2. 識別子に近い位置の要素から、順々に解釈を始める。何が優先されるのかは、Cの演算子の優先順位に準じる。この時、宣言の意味を区切るための( )がある場合は、その内容を先に解釈する。その後、配列の[ ]や関数の引数を囲う( )、ポインタを意味する*など、型宣言に伴う付属の記号を解釈する。なお、括弧の方が*よりも解釈は先に行われる。
3. 最後に、一番左にあるintやcharなどの型を解釈する。

1.3-2で取り上げた\verb’int (*p_array)[10]’と\verb’int *p_array_two[10]’の違いを表現した説明を、上記の手順に整理して行う。
	int (*p_array)[10]; //int型の要素を持つ要素数10の配列へのポインタp_arrayについて
	1. 識別子はp_arrayである。
	2. 識別子が括弧で囲まれているため、識別子に一番近い要素はポインタ型を表す”*”である。従って、p_arrayはポインタである。
	3. 次に近い要素は配列の要素数を表す括弧である。従って、p_arrayは配列を表すポインタであり、要素数は10である。
int *p_array_two[10]; //intへのポインタを要素に持つ要素数10の配列
この説明で行ったことこそが、上記の考え方でポインタを含む宣言を読んだものである。
このように、長い宣言や複雑な宣言であっても、識別子に注目したのちにそこから近い要素を読み解いていくことで、正しく読み書きすることができるようになる。

### 1.3-4　ポインタ型変数への代入に際しての注意
ポインタ型の変数において、想定されている型を持つもの以外のデータを指すアドレスは代入することができない。intのポインタ型変数a_pointerにchar型の変数cのアドレスを代入することはできず、char型へのポインタ型変数c_pointerにint型の変数aのアドレスを代入することもできない。これは、指す先のデータの型とポインタの想定する型が一致しないことによって正しくデータが呼び出せなくなってしまうことを防ぐためである。
仮に、想定されている型と違うデータのポインタでもポインタ型変数に代入できてしまうとする。例として、int型の変数aとcharへのポインタ変数c_pointerが存在するとして、c_pointerへaのアドレス0000を代入したとする。cを使ってメモリにアクセスする段階になって、c_pointerの持つ情報からメモリの中のデータを読み出す時、c_pointerが指すのは「char型で」「アドレス0000に存在するデータ」である。本来aのデータはアドレス0000から0003の4バイトに収まっているはずだが、char型の想定となりアドレス0000に格納された1バイト分しか読み込まれない。結果、予期せぬ挙動に発展することになる。

double型を想定している変数にint型の値を代入するなど、変数と型がちがう値を代入する必要がある際は、キャスト演算子を使用する。キャスト演算子は以下のように扱う。

(変換先の型) 型変換する式;

例えば、int型の変数aをchar型に変換したい場合、

x = (char) int a;

となる。








